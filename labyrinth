import string
import copy

#########################################################
#--------------------------------------------------------
#read maze as a graph
#--------------------------------------------------------
#########################################################

#Read maze as dictionary
data = open("labyrinth.dat","r")
field =  {}
y = 0
for line in data:
	x = 0
	y += 1
	for i in line.rstrip():
		field[(x,y)] = i		
		x += 1


#------------------------------------
#Turn into graph
#------------------------------------
#returns all adjecent paths/keys/doors (evrything but walls essentially)
def findadjecent(coordinate,field):
	temp = [0,0,0,0]
	output = []
	temp[0] = (coordinate[0]+1,coordinate[1])
	temp[1] = (coordinate[0]-1,coordinate[1])
	temp[2] = (coordinate[0],coordinate[1]+1)
	temp[3] = (coordinate[0],coordinate[1]-1)
	for i in temp:
		if i in field:
			if field[i] != "#":
				output.append(i)
	return output
#end of findadjecent

	
#finds all connected nodes for any given node in the given field
def findnext(node,statfield):
	current = set()		#current outer edges
	next = set()		#outer edges of next step
	field = copy.deepcopy(statfield)
	field[node] = "#"
	distance = 0
	output = set()

	#find the coordinates of the node in question
	for i in field:
		if field[i] == node:
			current.add(i)
			break

	#check evry tile next to the current outer edge
	while len(current)>0:
		distance += 1
		for i in current:
			adjecent = findadjecent(i,field)
			for j in adjecent:
				if field[j] == ".":
					next.add(j)
				else:
					output.add((field[j],distance))
				field[j] = "#"	#blocks this tile so the same tile is only found once
		#set current for the next step
		current = next
		next = set()
	return output
#end of findnext


#find evry node in the field
Nodes = set()
for i in field:
	if not(field[i] in [".","#"]):
		Nodes.add(field[i])


#for evry node get its connected nodes
graph = {}		#key = node, value = set of connected nodes as (node,distance)
for node in Nodes:	
	graph[node] = findnext(node,field)



#########################################################
#--------------------------------------------------------
#End of reading input
#--------------------------------------------------------
#calculate states consiting of (node,keys) and the shortest path each state recursivly
#--------------------------------------------------------
#########################################################

states = {}			#contains states and the pathlength	
totalkeys = 0		#path ends when len(collected) = totalkeys
for i in graph:
	if i in string.ascii_lowercase:
		totalkeys += 1


#outputs the list of keys that dont require travel through either locked door or uncollected key
def reachable(state):
	allowed = "@" + state[1]
	explored = set()
	current = set(state[0])
	found = set()
	output = set()
	while len(current) > 0:
		for node in current:
			for connected in graph[node]:
				if (connected[0] in allowed.lower()):
					if not(connected[0] in explored) and not(connected[0] in current):
						found.add(connected[0])
				else:
					if connected[0] in string.ascii_lowercase:
						output.add(connected[0])
			explored.add(node)
		current = found
		found = set()
	return output
#end of reachable
print(reachable(("@","")))	
#---------------------------------------------------------------------------
