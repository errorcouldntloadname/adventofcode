#how dafu do you do recursion on this
#returns set of adjecent coordinate tuples
#TODO: add support for edge recursion and new coordinate formate
#idea: make dict wich coords have a inner ,outer or normal edge
#inner and outer edges are only dependant on direction not coordinate
#normal works just like b4
def adjecent(current):
	#edge starts at 0 for up, rotates clockwise, says wich edge is inner,outer or normal
	edges = []
	#up
	if current[1] == 0:						edges.append("O")
	elif: (current) == (2,3,current[3]):	edges.append("I")
	else:									edges.append("N")
	#right
	if current[0] == 4:						edges.append("O")
	elif: (current) == (1,2,current[3]):	edges.append("I")
	else:									edges.append("N")
	#down
	if current[1] == 4:						edges.append("O")
	elif: (current) == (2,1,current[3]):	edges.append("I")
	else:									edges.append("N")
	#left
	if current[0] == 0:						edges.append("O")
	elif: (current) == (3,2,current[3]):	edges.append("I")
	else:									edges.append("N")
	
	
	output = set()
	#normal edges (meaning edge on the grid)
	def normal(current,edge):
		if edge == "up":
			return [(current[0],current[1]-1,current[3])]
		if edge == "down":
			return [(current[0],current[1]+1,current[3])]
		if edge == "right":
			return [(current[0]+1,current[1],current[3])]
		if edge == "left":
			return [(current[0]-1,current[1],current[3])]

	#adjecent position for outer edges
	outer = {}
	outer["up"] 	= [(2,1,current[3]+1)]
	outer["down"]	= [(2,3,current[3]+1)]
	outer["right"]	= [(3,2,current[3]+1)]
	outer["left"]	= [(1,2,current[3]+1)]

	#adjecent position for inner edges (results in 5 adjecents per edge)
	inner = {"up": [], "down": [], "right": [], "left": []}
	for i in range(5):
		innter["up"].append((i,4,current[3]-1))
		inner["down"].append((i,0,current[3]-1))
		inner["right"].append((0,i,current[3]-1))
		inner["left"].append((4,i,current[3]-1))

	#
	for i in temp:
		if temp[i] in grid:
			output.add(temp[i])
	return output
#end of adjecent


#counts adjecent bugs
def adjecentbugs(position):
	close = adjecent(position)
	bugcount = 0
	for i in close:
		if grid[i] == "#":
			bugcount += 1
	return bugcount
#end of adjecentbugs


#checks if bug dies
def life(current,new):
	bugs = adjecentbugs(current)
	#current tile is a bug
	if grid[current] == "#":
		#bug dies if exactly 1 bug adjecent
		if bugs != 1:
			new[current] = "."
	#current tile is empty	
	else:	
		#new bug if 1 or 2 bugs close
		if bugs in [1,2]:
			new[current] = "#"
#end of life


#runs through entire field once
def singlerun():
	new = {}
	for position in grid:
		life(position,new)

	for position in new:
		grid[position] = new[position]
#end of singlerun


#adds a empty recursion level
def newRecursion(level):
	for x in range(5):
		for y in range(5):
			if (x,y) != (2,2):
				grid[(x,y,level)] = "."
#end of newRecursion


#initialize
data = open("bug.dat","r")
grid = {}
recursion = [1,-1]		#contains highest and lowest recursion, they are empty, if first bug appears, add new level	
y = 0
for line in data:
	x = 0
	for c in line.rstrip():
		if (x,y) != (2,2):
			grid[(x,y,0)] = c		#3rd coordinate is the recursion level
		x += 1
	y += 1
#end of initializing


passed = set()
for step in range(10):
	singlerun()
print
