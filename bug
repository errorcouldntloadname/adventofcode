#how dafu do you do recursion on this
#returns set of adjecent coordinate tuples
#TODO: add support for edge recursion and new coordinate formate
def adjecent(current):
	output = set()
	temp = {}
	temp["up"]    = (current[0],current[1]-1)
	temp["down"]  = (current[0],current[1]+1)
	temp["right"] = (current[0]+1,current[1])
	temp["left"]  = (current[0]-1,current[1])

	for i in temp:
		if temp[i] in grid:
			output.add(temp[i])
	return output
#end of adjecent


#counts adjecent bugs
def adjecentbugs(position):
	close = adjecent(position)
	bugcount = 0
	for i in close:
		if grid[i] == "#":
			bugcount += 1
	return bugcount
#end of adjecentbugs


#checks if bug dies
def life(current,new):
	bugs = adjecentbugs(current)
	#current tile is a bug
	if grid[current] == "#":
		#bug dies if exactly 1 bug adjecent
		if bugs != 1:
			new[current] = "."
	#current tile is empty	
	else:	
		#new bug if 1 or 2 bugs close
		if bugs in [1,2]:
			new[current] = "#"
#end of life


#runs through entire field once
def singlerun():
	new = {}
	for position in grid:
		life(position,new)

	for position in new:
		grid[position] = new[position]
#end of singlerun


data = open("bug.dat","r")
grid = {}
recursion = [1,-1]		#contains highest and lowest recursion, they are empty, if first bug appears, add new level	
y = 0
for line in data:
	x = 0
	for c in line.rstrip():
		if (x,y) != (2,2):
			grid[(x,y,0)] = c		#3rd coordinate is the recursion level
		x += 1
	y += 1

passed = set()
for step in range(10):
	singlerun()
print
